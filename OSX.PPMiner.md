# OSX/PPMiner

SHA256 sums:
* a00f6fbb2e00d35f938534e1c20ba2e02311536bcf60be2165037d68cba141b2  mshelper
* 8f1938d082393713539abb9dfa8bfde8e1a09721f622e6e597d4560219ffca0d  pplauncher

## Miner: mshelper
XMRig miner.
```bash
$ otool -L mshelper 
mshelper:
	@executable_path/libmicrohttpd.12.dylib (compatibility version 59.0.0, current version 59.0.0)
	/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 307.5.0)
	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.60.2)

$ codesign -v mshelper 
  mshelper: code object is not signed at all
  In architecture: x86_64
$ strings -a mshelper | grep XMRig
XMRig 2.5.1
[01;36mXMRig/%s
 * VERSIONS:     XMRig/%s libuv/%s%s
XMRig
```

## Dropper: pplauncher
Written in Go and the one dropping the payload.
```bash
$ file pplauncher 
pplauncher: Mach-O 64-bit executable x86_64
$ strings -a pplauncher | head
 Go build ID: "3xkvDz8awVOl0TA6jJs9/tcgWkdP85A-MJ6hpnmKm/_xkzRloiGp8H5mHsQgkh/7Kj4aF9BTT0MY_gaQnQI"
AWAVATSH
[A\A^A_]
AWAVSPH
[A^A_]
AWAVSPH
[A^A_]
AWAVATSH
fffff.
[A\A^A_]
```

### Interesting functions and behaviour
```bash
$ gobjdump -j .text -x pplauncher | grep 'main\.'
00000000010eb7a0 l       0e SECT   01 0000 [.text] main.(*bindataFileInfo).IsDir
00000000010eb710 l       0e SECT   01 0000 [.text] main.(*bindataFileInfo).ModTime
00000000010eb690 l       0e SECT   01 0000 [.text] main.(*bindataFileInfo).Mode
00000000010eb590 l       0e SECT   01 0000 [.text] main.(*bindataFileInfo).Name
00000000010eb610 l       0e SECT   01 0000 [.text] main.(*bindataFileInfo).Size
00000000010eb820 l       0e SECT   01 0000 [.text] main.(*bindataFileInfo).Sys
00000000010e9d90 l       0e SECT   01 0000 [.text] main.Asset
00000000010ead30 l       0e SECT   01 0000 [.text] main.autoKill
00000000010eaf70 l       0e SECT   01 0000 [.text] main.autoKill.func1
00000000010e9830 l       0e SECT   01 0000 [.text] main.bindataFileInfo.IsDir
00000000010e9810 l       0e SECT   01 0000 [.text] main.bindataFileInfo.ModTime
00000000010e9800 l       0e SECT   01 0000 [.text] main.bindataFileInfo.Mode
00000000010e97d0 l       0e SECT   01 0000 [.text] main.bindataFileInfo.Name
00000000010e97f0 l       0e SECT   01 0000 [.text] main.bindataFileInfo.Size
00000000010e9840 l       0e SECT   01 0000 [.text] main.bindataFileInfo.Sys
00000000010e93c0 l       0e SECT   01 0000 [.text] main.bindataRead
00000000010ea140 l       0e SECT   01 0000 [.text] main.check
00000000010ea1a0 l       0e SECT   01 0000 [.text] main.cleanupMinerDirectory
00000000010e9900 l       0e SECT   01 0000 [.text] main.dataLibmicrohttpd12Dylib
00000000010e9850 l       0e SECT   01 0000 [.text] main.dataLibmicrohttpd12DylibBytes
00000000010e9ba0 l       0e SECT   01 0000 [.text] main.dataMshelper
00000000010e9af0 l       0e SECT   01 0000 [.text] main.dataMshelperBytes
00000000010eacc0 l       0e SECT   01 0000 [.text] main.exitGracefully
00000000010ea390 l       0e SECT   01 0000 [.text] main.extractPayload
00000000010ea650 l       0e SECT   01 0000 [.text] main.fetchConfig
00000000010ead80 l       0e SECT   01 0000 [.text] main.handleExit
00000000010eafc0 l       0e SECT   01 0000 [.text] main.handleExit.func1
00000000010eb010 l       0e SECT   01 0000 [.text] main.init
00000000010ea0a0 l       0e SECT   01 0000 [.text] main.init.0
00000000010eab00 l       0e SECT   01 0000 [.text] main.launchMiner
00000000010eae60 l       0e SECT   01 0000 [.text] main.main
0000000001050e20 l       0e SECT   01 0000 [.text] runtime.main.func1
0000000001050e70 l       0e SECT   01 0000 [.text] runtime.main.func2
00000000010eb4b0 l       0e SECT   01 0000 [.text] type..eq.main.bindataFileInfo
00000000010eb400 l       0e SECT   01 0000 [.text] type..hash.main.bindataFileInfo
```

At the begining (on func main) already calls a lot of functions:
```asm
call    main_autoKill
call    main_handleExit
call    main_cleanupMinerDirectory
call    main_extractPayload
call    main_fetchConfig
```
### main_autoKill
Is a goroutine that spawns a new process and calls function **main_autoKill_func1**. This function sleeps for 1A3185C5000h and then calls **main_exitGracefully**. So it acts as a safe way to say goodbye if something goes wrong.
### main_exitGracefully
Sets the variable *exiting* to 1, calls **main_cleanupMinerDirectory** and checks if the miner is running:
```asm
mov     cs:main_exiting, 1
call    main_cleanupMinerDirectory
mov     rax, cs:main_minerCmd
test    rax, rax
jnz     short loc_10EAD0C
```
If it is then kill it and exit:
```asm
loc_10EAD0C:
mov     rax, [rax+0A0h]
mov     [rsp+20h+var_20], rax
call    os___Process__Kill
jmp     short loc_10EACF5
loc_10EACF5:
mov     [rsp+20h+var_20], 0
call    os_Exit
mov     rbp, [rsp+20h+var_8]
add     rsp, 20h
retn
```
### main_cleanupMinerDirectory
Checks if **/tmp/mshelper** exists if not opens the directory and starts checking for the file. If exists then removes it:
```asm
lea     rax, miner_path
mov     [rsp+80h+names.array], rax
mov     [rsp+80h+names.len], 0Dh
call    os_Stat
...
call    os_Open
...
call    os_Remove
```
### main_handleExit
Going back to the main function we have this function next that deals with signals. Catches KILL signals and spawns a new goroutine (**main_handleExit_func1**) that does de graceful exit.
### main_extractPayload
This function is the one in charge of delivering the miner to **/tmp/mshelper/** creating the necessary directories:
```asm
lea     rax, miner_path
mov     [rsp+0A0h+_r1.array], rax
mov     [rsp+0A0h+_r1.len], 0Dh
mov     dword ptr [rsp+0A0h+_r1.cap], 1FFh
call    os_MkdirAll
```
And writing the data:
```asm
__text:00000000010EA4C3 loc_10EA4C3:                            ; CODE XREF: main_extractPayload+27A↓j
...
__text:00000000010EA59E                 mov     [rsp+0A0h+_r1.array], rax ; data
__text:00000000010EA5A2                 mov     [rsp+0A0h+_r1.len], rcx
__text:00000000010EA5A7                 mov     rax, [rsp+0A0h+binFile.ptr]
__text:00000000010EA5AF                 mov     [rsp+0A0h+_r1.cap], rax
__text:00000000010EA5B4                 mov     rax, [rsp+0A0h+binFile.len_0]
__text:00000000010EA5B9                 mov     [rsp+0A0h+var_88], rax
__text:00000000010EA5BE                 mov     rax, [rsp+0A0h+binFile.cap_0]
__text:00000000010EA5C3                 mov     [rsp+0A0h+var_80], rax
__text:00000000010EA5C8                 mov     dword ptr [rsp+0A0h+_r2.array], 1A4h
__text:00000000010EA5D0                 call    io_ioutil_WriteFile
__text:00000000010EA5D5                 mov     rax, [rsp+0A0h+_r2.len]
__text:00000000010EA5DA                 mov     rcx, [rsp+0A0h+_r2.cap]
__text:00000000010EA5DF                 mov     [rsp+0A0h+_r1.array], rax
__text:00000000010EA5E3                 mov     [rsp+0A0h+_r1.len], rcx
__text:00000000010EA5E8                 call    main_check
__text:00000000010EA5ED                 mov     rax, [rsp+0A0h+var_10]
__text:00000000010EA5F5                 add     rax, 10h
__text:00000000010EA5F9                 mov     rcx, [rsp+0A0h+var_38]
__text:00000000010EA5FE                 lea     rdx, [rcx+1]
__text:00000000010EA602                 mov     rcx, [rsp+0A0h+var_30]
__text:00000000010EA607
__text:00000000010EA607 loc_10EA607:                            ; CODE XREF: main_extractPayload+12E↑j
__text:00000000010EA607                 cmp     rdx, rcx
__text:00000000010EA60A                 jl      loc_10EA4C3
```
### main_fetchConfig
Now to the juicy part: here he gets the config from the server **a.ppcdn.xyz**'s TXT records:
```bash
$ dig @8.8.8.8 a.ppcdn.xyz txt +nostats
  
; <<>> DiG 9.10.6 <<>> @8.8.8.8 a.ppcdn.xyz txt +nostats
; (1 server found)
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 1422
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

  
;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 512
;; QUESTION SECTION:
;a.ppcdn.xyz.  IN  TXT

  
;; ANSWER SECTION:
a.ppcdn.xyz.  299  IN  TXT  "!!46AVJLta2CB1zhLHx15xidEPMQYsSsnVxah1QVNPF37dJefd3emB5usPg8b2oWAvFMeW2tDNKr9kSa9xoGvaYuxF9kGeCvK,44a8vnNcnyEBuSxkxVZKUJKBx1zwgC4quVMP4isECUdJayBgYshHdHdXrnQN5GFZ94WDnyKfq3dgqYvhW5YbTtkD1YnR9wZ"
```
Whois will return no information regarding this FQDN.
### main_launchMiner
The launcher. Uses *os.exec.Command()* to execute the command (**main.minerCmd**) using the address and pools from config.
